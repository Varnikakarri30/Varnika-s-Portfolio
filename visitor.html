<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visitor - Varnika Karri Portfolio</title>
    
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    


    
    <!-- Custom CSS -->
    <link rel="stylesheet" href="style.css">
    
    <!-- White Background Override -->
    <style>
        body.visitor-theme {
            background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%) !important;
            color: #333333 !important;
        }
        
        .hero-text h1 {
            color: #333333 !important;
        }
        
        .hero-text p {
            color: #666666 !important;
        }
    </style>
    
    <!-- Three.js for 3D Avatar -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/fflate@0.7.4/umd/index.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/FBXLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/DRACOLoader.js"></script>
</head>
<body class="visitor-theme">
    
   

    <!-- Hero Section with 3D Avatar -->
    <section class="visitor-hero">
        <div class="hero-container">
            <!-- Left Side - Introduction Text -->
            <div class="hero-text">
                <h1>Hi, I'm Varnika</h1>
                <p class="hero-description">
                    A passionate developer, designer, and innovator creating digital experiences 
                    that bridge creativity with technology. I love building solutions that make 
                    a difference and bring ideas to life.
                </p>
                <div class="hero-buttons">
                    <button class="btn-primary">Explore My Work</button>
                    <button class="btn-secondary">Get In Touch</button>
                </div>
            </div>
            
            <!-- Right Side - 3D Avatar -->
            <div class="hero-avatar">
                <div id="avatar-container" style="border: none !important; box-shadow: none !important; outline: none !important;">
                    <div id="loading-indicator" style="display: flex; align-items: center; justify-content: center; height: 100%; color: #3b82f6; font-size: 1.2rem;">
                        Loading 3D Avatar...
                    </div>
                </div>
            </div>
        </div>
    </section>

    <!-- Three.js 3D Avatar Script -->
    <script>
        let scene, camera, renderer, avatar, mixer, clock;
        
        function initAvatar() {
            console.log('Initializing 3D Avatar...');
            
            // Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xffffff);
            
            // Camera setup - positioned to see full avatar
            const container = document.getElementById('avatar-container');
            if (!container) {
                console.error('Avatar container not found!');
                return;
            }
            
            console.log('Container found:', container);
            console.log('Container dimensions:', container.clientWidth, 'x', container.clientHeight);
            
            const width = container.clientWidth;
            const height = container.clientHeight;
            
            camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
            camera.position.set(0, 1.5, 6);
            camera.lookAt(0, 0, 0);
            
            // Renderer setup
            renderer = new THREE.WebGLRenderer({ 
                antialias: true, 
                alpha: true,
                powerPreference: "high-performance"
            });
            renderer.setSize(width, height);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.outputEncoding = THREE.sRGBEncoding;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2;
            
            // Clear the loading indicator and add renderer
            container.innerHTML = '';
            container.appendChild(renderer.domElement);
            console.log('Renderer added to container');
            
            // Lighting setup
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 5, 5);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 50;
            scene.add(directionalLight);
            
            // Add some additional lighting for better visibility
            const pointLight = new THREE.PointLight(0xffffff, 0.5);
            pointLight.position.set(-5, 5, 5);
            scene.add(pointLight);
            
            // Initialize clock for animations
            clock = new THREE.Clock();
            
            // Create fallback avatar immediately since FBX isn't working
            console.log('Creating fallback avatar immediately');
            createFallbackAvatar();
            
            // Try to load FBX model in background (optional)
            // loadFBXAvatar();
            
            // Start the render loop
            animate();
        }
        
        function loadFBXAvatar() {
            // Check if FBXLoader is available
            if (typeof THREE.FBXLoader === 'undefined') {
                console.log('FBXLoader not available, creating fallback avatar');
                createFallbackAvatar();
                return;
            }

            const fbxLoader = new THREE.FBXLoader();

            fbxLoader.load(
                'Waving.fbx',
                function(object) {
                    console.log('FBX model loaded successfully');
                    
                    // Remove any existing avatar
                    if (avatar) {
                        scene.remove(avatar);
                    }

                    avatar = object;

                    // Make sure the model is visible
                    avatar.visible = true;
                    avatar.traverse(function(child) {
                        if (child.isMesh) {
                            child.visible = true;
                            child.frustumCulled = false;
                            child.castShadow = true;
                            child.receiveShadow = true;
                            
                            // Make materials more visible
                            if (child.material) {
                                if (Array.isArray(child.material)) {
                                    child.material.forEach(mat => {
                                        mat.transparent = false;
                                        mat.opacity = 1.0;
                                        mat.wireframe = false;
                                    });
                                } else {
                                    child.material.transparent = false;
                                    child.material.opacity = 1.0;
                                    child.material.wireframe = false;
                                }
                            }
                        }
                    });

                    // Get model bounding box to calculate proper scale and position
                    const box = new THREE.Box3().setFromObject(avatar);
                    const size = box.getSize(new THREE.Vector3());
                    const center = box.getCenter(new THREE.Vector3());
                    
                    console.log('FBX Model dimensions:', size);
                    console.log('FBX Model center:', center);

                    // Calculate proper scale to fit in view
                    const maxDimension = Math.max(size.x, size.y, size.z);
                    const targetSize = 3; // Target size set to 3
                    const scaleFactor = targetSize / maxDimension;
                    
                    console.log('Scale factor:', scaleFactor);
                    
                    // Apply scale and position - make it much larger and center it
                    avatar.scale.setScalar(scaleFactor * 5.0); // Make it much larger
                    avatar.position.set(0, -center.y, 0); // Center it
                    
                    // Position camera to see the full model
                    camera.position.set(0, 2, 8);
                    camera.lookAt(0, 0, 0);
                    
                    // Add to scene
                    scene.add(avatar);
                    console.log('Avatar added to scene. Scene children count:', scene.children.length);
                    
                    // Add a test cube to verify scene is working
                    const testGeometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
                    const testMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
                    const testCube = new THREE.Mesh(testGeometry, testMaterial);
                    testCube.position.set(0, 0, 0);
                    scene.add(testCube);
                    console.log('Test cube added. Scene children count:', scene.children.length);
                    
                    // Set up animation mixer if animations exist
                    if (avatar.animations && avatar.animations.length > 0) {
                        mixer = new THREE.AnimationMixer(avatar);
                        const action = mixer.clipAction(avatar.animations[0]);
                        action.play();
                    }
                    
                    // Fine-tune after a short delay
                    setTimeout(() => {
                        avatar.scale.setScalar(scaleFactor * 8.0); // Even larger for better visibility
                        avatar.position.set(0, -center.y, 0); // Keep centered
                        camera.position.set(0, 3, 10); // Adjust camera to see the avatar
                        camera.lookAt(0, 0, 0);
                        console.log('Avatar fine-tuned - scale:', avatar.scale, 'position:', avatar.position);
                    }, 1000);
                },
                function(progress) {
                    // Loading progress (no console output)
                },
                function(error) {
                    console.log('FBX loading failed:', error);
                    // If FBX fails, create fallback avatar
                    createFallbackAvatar();
                }
            );
        }
        
        function createFallbackAvatar() {
            console.log('Creating fallback avatar...');
            
            // Remove any existing avatar
            if (avatar) {
                scene.remove(avatar);
            }
            
            // Create a simple fallback avatar
            const group = new THREE.Group();
            
            // Body
            const bodyGeometry = new THREE.CylinderGeometry(0.3, 0.4, 1.2, 8);
            const bodyMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 }); // Bright red
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0.2;
            body.castShadow = true;
            group.add(body);
            
            // Head
            const headGeometry = new THREE.SphereGeometry(0.25, 16, 16);
            const headMaterial = new THREE.MeshLambertMaterial({ color: 0xffdbac });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 1.1;
            head.castShadow = true;
            group.add(head);
            
            // Hair
            const hairGeometry = new THREE.SphereGeometry(0.28, 16, 16);
            const hairMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 }); // Bright green
            const hair = new THREE.Mesh(hairGeometry, hairMaterial);
            hair.position.y = 1.2;
            hair.scale.y = 0.8;
            group.add(hair);
            
            // Eyes
            const eyeGeometry = new THREE.SphereGeometry(0.05, 8, 8);
            const eyeMaterial = new THREE.MeshLambertMaterial({ color: 0x000000 });
            
            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(-0.08, 1.15, 0.2);
            group.add(leftEye);
            
            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(0.08, 1.15, 0.2);
            group.add(rightEye);
            
            // Smile
            const smileGeometry = new THREE.TorusGeometry(0.1, 0.02, 4, 8, Math.PI);
            const smileMaterial = new THREE.MeshLambertMaterial({ color: 0x000000 });
            const smile = new THREE.Mesh(smileGeometry, smileMaterial);
            smile.position.set(0, 1.05, 0.2);
            smile.rotation.z = Math.PI;
            group.add(smile);
            
            // Arms
            const armGeometry = new THREE.CylinderGeometry(0.08, 0.1, 0.8, 8);
            const armMaterial = new THREE.MeshLambertMaterial({ color: 0xffdbac });
            
            const leftArm = new THREE.Mesh(armGeometry, armMaterial);
            leftArm.position.set(-0.5, 0.5, 0);
            leftArm.rotation.z = 0.3;
            leftArm.castShadow = true;
            group.add(leftArm);
            
            const rightArm = new THREE.Mesh(armGeometry, armMaterial);
            rightArm.position.set(0.5, 0.5, 0);
            rightArm.rotation.z = -0.3;
            rightArm.castShadow = true;
            group.add(rightArm);
            
            // Hands
            const handGeometry = new THREE.SphereGeometry(0.1, 8, 8);
            const handMaterial = new THREE.MeshLambertMaterial({ color: 0xffdbac });
            
            const leftHand = new THREE.Mesh(handGeometry, handMaterial);
            leftHand.position.set(-0.7, 0.1, 0);
            leftHand.castShadow = true;
            group.add(leftHand);
            
            const rightHand = new THREE.Mesh(handGeometry, handMaterial);
            rightHand.position.set(0.7, 0.1, 0);
            rightHand.castShadow = true;
            group.add(rightHand);
            
            // Legs
            const legGeometry = new THREE.CylinderGeometry(0.1, 0.12, 0.8, 8);
            const legMaterial = new THREE.MeshBasicMaterial({ color: 0x0000ff }); // Bright blue
            
            const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
            leftLeg.position.set(-0.15, -0.6, 0);
            leftLeg.castShadow = true;
            group.add(leftLeg);
            
            const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
            rightLeg.position.set(0.15, -0.6, 0);
            rightLeg.castShadow = true;
            group.add(rightLeg);
            
            // Feet
            const footGeometry = new THREE.BoxGeometry(0.2, 0.1, 0.4);
            const footMaterial = new THREE.MeshLambertMaterial({ color: 0x000000 });
            
            const leftFoot = new THREE.Mesh(footGeometry, footMaterial);
            leftFoot.position.set(-0.15, -1.1, 0.1);
            leftFoot.castShadow = true;
            group.add(leftFoot);
            
            const rightFoot = new THREE.Mesh(footGeometry, footMaterial);
            rightFoot.position.set(0.15, -1.1, 0.1);
            rightFoot.castShadow = true;
            group.add(rightFoot);
            
            // Set up the fallback avatar
            avatar = group;
            avatar.scale.setScalar(4.0); // Make it much larger
            avatar.position.set(0, 0, 0); // Center it
            scene.add(avatar);
            
            console.log('Fallback avatar created and added to scene');
            console.log('Avatar scale:', avatar.scale);
            console.log('Avatar position:', avatar.position);
            
            // Add a simple waving animation
            const waveAnimation = () => {
                if (rightArm) {
                    rightArm.rotation.z = -0.3 + Math.sin(clock.getElapsedTime() * 3) * 0.2;
                }
            };
            
            // Store the animation function
            avatar.userData.animate = waveAnimation;
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            // Update animation mixer
            if (mixer) {
                mixer.update(clock.getDelta());
            }
            
            // Run custom animations
            if (avatar && avatar.userData.animate) {
                avatar.userData.animate();
            }
            
            // Add a subtle floating animation for the fallback avatar
            if (avatar && !mixer) {
                avatar.position.y = -0.3 + Math.sin(clock.getElapsedTime() * 2) * 0.05;
            }
            
            // Rotate the test cube
            const cube = scene.children.find(child => child.geometry && child.geometry.type === 'BoxGeometry');
            if (cube) {
                cube.rotation.x += 0.01;
                cube.rotation.y += 0.01;
            }
            
            // Debug: Log scene info every 60 frames (about once per second)
            if (Math.floor(clock.getElapsedTime()) % 1 === 0 && Math.floor(clock.getElapsedTime() * 60) % 60 === 0) {
                console.log('Scene children:', scene.children.length);
                console.log('Avatar visible:', avatar ? avatar.visible : 'no avatar');
                console.log('Camera position:', camera.position);
            }
            
            renderer.render(scene, camera);
        }
        
        // Initialize when page loads
        window.addEventListener('load', initAvatar);
        
        // Handle window resize
        window.addEventListener('resize', function() {
            const container = document.getElementById('avatar-container');
            if (camera && renderer && container) {
                const newWidth = container.clientWidth;
                const newHeight = container.clientHeight;
                camera.aspect = newWidth / newHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(newWidth, newHeight);
            }
        });
    </script>
</body>
</html>